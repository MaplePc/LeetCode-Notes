31. Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
======================================================================
对代码做法的补充:
在数组中试图找到一个位置最靠后的元素a, 使得它能跟后面的元素中位置最靠后并且值比a大的元素b交换位置, 然后使b后面的所有元素升序排列; 
如果不能找到上述的两个元素, 说明该数组中的元素是降序排列的, 此时令下标和等于length-1的所有元素对互换位置.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len < 2){
            return;
        }
        int[] indexArr = new int[len]; //利用一个数组来存放依次找到的最大值的下标
        int indexArrI = 0; //indexArr数组的下标
        int maxI = indexArr[indexArrI++] = len - 1;
        for(int i = len - 2; i > -1; i--){
            if(nums[i] > nums[maxI]){	//如果找到了新的最大值
                maxI = i;
                indexArr[indexArrI++] = i;
            }
            else if(nums[i] < nums[maxI]){
                int targetIndex = search(nums, indexArr, indexArrI, nums[i]); //targetIndex是第一个大于nums[i]的元素的下标
                swap(nums, i, targetIndex);
                Arrays.sort(nums, i + 1, len);
                return;
            }
        }
        int half = len / 2; //如果数组是降序排列, 则变为升序
        for(int i = 0; i < half; i++){
            swap(nums, i, len - 1 - i);
        }
    }
    public static void swap(int[] a, int i, int j){
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    //类二分查找方法, 但是目的是想把恰大于target的元素找出来
    /**
     * @param a 存储具体元素值的数组
     * @param index 存储数组的最大值的下标的数组, 如{第0次找到的最大值, 第1次找到的最大值, 第2次...}
     * @param indexLen index数组的长度
     * @param target 目标元素的值
     * @return 数组中从尾到头方向第一个大于target的元素的下标
     */
    public static int search(int[] a, int[] index, int indexLen, int target){ //
		int l = 0;
		int r = indexLen - 1;//
        int midI = 0;
		while(l <= r){//
			midI = l + (r - l) / 2;//
			int middle = a[index[midI]];
			if(target < middle){
				r = midI - 1;
			}
			else if(target >= middle){ //此会丢弃等于target的元素
				l = midI + 1;
			}
		}
        if(r == midI - 1)
		    return index[midI];
        else 
            return index[midI + 1];
	}
}




