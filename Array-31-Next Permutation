31. Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
======================================================================
对代码做法的补充:
在数组中试图找到一个位置最靠后的元素a, 使得它能跟后面的元素中位置最靠后并且值比a大的元素b交换位置, 然后使b后面的所有元素升序排列; 
如果不能找到上述的两个元素, 说明该数组中的元素是降序排列的, 此时令下标和等于length-1的所有元素对互换位置.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len < 2){
            return;
        }
        int maxI = len - 1;     //记录最大值元素的下标
        for(int i = len - 2; i > -1; i--){
            if(nums[i] > nums[maxI]){ //此时可判断出不能找到所需的a,b元素
                maxI = i;
            }
            else if(nums[i] < nums[maxI]){
                for(int j = len - 1; j >= maxI; j--){ //注意j >= maxI, 而不是j > i,这样可以进一步缩小查找范围
                    if(nums[i] < nums[j]){ //找到了a,b元素
                        swap(nums, i, j);  //交换a,b元素
                        Arrays.sort(nums, i + 1, len); //对b元素所处的新位置的后面的所有元素进行升序排列
                        return;
                    }
                }
            }
        }
        int half = len / 2;
        for(int i = 0; i < half; i++){
            swap(nums, i, len - 1 - i);
        }
    }
    public static void swap(int[] a, int i, int j){
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
