A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2.
=====================================
class Solution {
    char[] cs;
    boolean error = false;
    Map<Integer, Integer> map = new HashMap<>();
    public int numDecodings(String s) {
        if(s.length() == 0)
            return 0;
        cs = s.toCharArray();
        int res = helper(0);
        return error ? 0 : res;
    }
    public int helper(int start){
        if(start == cs.length)
            return 1;
        else if(error || start > cs.length)
            return 0;
        
        Integer r = map.get(start);
        if(r != null)
        	return r;
        
        int res = 0;
        if(cs[start] == '1'){
        	if(start + 2 < cs.length && cs[start + 2] == '0')
        		res += helper(start + 1);
        	else if(start + 1 < cs.length && cs[start + 1] == '0')
                res += helper(start + 2);
            else
            	res += helper(start + 1) + helper(start + 2);
        }
        else if(cs[start] == '2'){
        	if(start + 2 < cs.length && cs[start + 2] == '0')
        		res += helper(start + 1);
        	else if(start + 1 < cs.length){
                if(cs[start + 1] == '0')
                    res += helper(start + 2);
                else{
                	res += helper(start + 1);
                	if(cs[start + 1] > '0' && cs[start + 1] < '7')
                		res += helper(start + 2);
                	return res;
                }
            }
            else
            	res += 1;
        }
        else if(cs[start] == '0'){
            error = true;
            return 0;
        }
        else
            res += helper(start + 1);
        
        map.put(start, res);
        return res;
    }
}
//56%
//减治法(从左到右确定当前字符只能单独一个,或跟后面一个字符结合, 然后递归求出两种方案的方法数,在求和)
//使用Map来保存已经遍历过的结果, 然后算法复杂度约为O(n); 如果不使用,将会是O(2n),2的n次方
