Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.
=============================================
class Solution {
	public int maxProduct(int[] nums) {
		int len = nums.length;
		int start = 0; //被0或开头结尾划分的一串连续的数字,start是这串数字的第一个元素的下标
		int product = 1; //局部累乘
		int positiveProduct = 1; //正数积局部最大值
		int res = Integer.MIN_VALUE;

		for (int i = 0; i < len; i++) {
			if (nums[i] > 0) { //正数
				product *= nums[i];
				positiveProduct *= nums[i];
			} else if (nums[i] < 0) { //当前元素为负数
				product *= nums[i];

        //更新res和positiveProduct
				if (product < 0) {
					if (positiveProduct > 1 && res < positiveProduct)
						res = positiveProduct;
					positiveProduct = 1;
				} else {
					if (res < product)
						res = product;
					positiveProduct = product;
				}
			} else { //当前元素为0
				if (product < 0 && start < i - 1) {
					product = reviewNegative(nums, product, start, i); //检查这一串乘积为负的数字
					
					if (res < product)
						res = product;
				} 
        else if (product > 1) //更新res的值
					res = Math.max(product, res);
				else if (positiveProduct > 1)
					res = Math.max(positiveProduct, res);

				start = i + 1; //新的数字串重新开始!!!
				product = 1;
				positiveProduct = 1;
			}

			if (res < nums[i]) //重要
				res = nums[i];
		}
		
		if (product < 0 && start < len - 1) //检查这一串乘积为负的数字
			product = reviewNegative(nums, product, start, len);
        
		if (product > 1)
			return Math.max(product, res);
		else if (positiveProduct > 1)
			return Math.max(positiveProduct, res);
		else
			return res;
	}

  //检查这一串乘积为负的数字
	public int reviewNegative(int[] nums, int product, int start, int end) { //包括start, 不包括end
		int negativeProduct_pre = 1;
		for (int j = start; j < end; j++) {
			negativeProduct_pre *= nums[j];
			if (nums[j] < 0)
				break;
		}

		int negativeProduct_back = 1;
		for (int j = end - 1; j >= start; j--) {
			negativeProduct_back *= nums[j];
			if (nums[j] < 0)
				break;
		}

		return product / Math.max(negativeProduct_pre, negativeProduct_back);
	}
}
//89%
