Note: This is an extension of House Robber.

After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Credits:
Special thanks to @Freezen for adding this problem and creating all test cases.
===========================================
class Solution {
	public int rob(int[] nums) {
		final int len = nums.length;
		int res = 0;
		if (len == 0)
			return 0;
		else if (len < 4) {
			for (int v : nums)
				if (v > res)
					res = v;
		}
		boolean[] sign = new boolean[nums.length];
		if (nums[0] > nums[nums.length - 1]) { //只选择第一个
			sign[0] = true;
			nums[2] += nums[0];
			sign[2] = true;
			for (int i = 3; i < nums.length - 1; i++) {
				if (nums[i - 2] > nums[i - 3]) {
					nums[i] += nums[i - 2];
					sign[i] = sign[i - 2];
				} else if (nums[i - 2] < nums[i - 3]) {
					nums[i] += nums[i - 3];
					sign[i] = sign[i - 3];
				} else {
					nums[i] += nums[i - 2];
					if (sign[i - 2] == false && sign[i - 3] == false)
						sign[i] = false;
					else
						sign[i] = true;
				}
			}
			nums[len - 1] += Math.max(sign[len - 3] ? 0 : nums[len - 3], sign[len - 4] ? 0 : nums[len - 4]);
			return Math.max(nums[len - 1], nums[len - 2]);
		}

		else { //只选择最后一个
			sign[len - 1] = true;
			nums[len - 3] += nums[len - 1];
			sign[len - 3] = true;
			for (int i = len - 4; i > 0; i--) {
				if (nums[i + 2] > nums[i + 3]) {
					nums[i] += nums[i + 2];
					sign[i] = sign[i + 2];
				} else if (nums[i + 2] < nums[i + 3]) {
					nums[i] += nums[i + 3];
					sign[i] = sign[i + 3];
				} else {
					nums[i] += nums[i + 2];
					if (sign[i + 2] == false && sign[i + 3] == false)
						sign[i] = false;
					else
						sign[i] = true;
				}
			}
			nums[0] += Math.max(sign[2] ? 0 : nums[2], sign[3] ? 0 : nums[3]);
			return Math.max(nums[0], nums[1]);
		}
	}
}
//80%
