 
Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.

You need to find the shortest such subarray and output its length.

Example 1:
Input: [2, 6, 4, 8, 10, 9, 15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
Note:
Then length of the input array is in range [1, 10,000].
The input array may contain duplicates, so ascending order here means <=.
===================================================
class Solution {
	public int findUnsortedSubarray(int[] nums) {
		int len = nums.length;
		if (len < 2) {
			return 0;
		}

		int i = 1;
		for (; i < len; i++)
			if (nums[i] < nums[i - 1]) // 首先尝试从前往后寻找第一个不按升序排列的元素
				break;
		if (i == len) // 如果找不到这样的i,说明是已经是升序排列
			return 0;

		int j = i;
		if (i < len - 1) // i后面还有元素
			for (j = len - 2; j > i; j--)// 其次尝试从后往前寻找第一个不按升序排列的元素
				if (nums[j] > nums[j + 1])
					break;

		// 如果i == len - 1 i后面无元素
		// 如果j == i && i < len - 1, 说明i元素的前后都是升序排列, 但nums[i] 与nums[j]的大小关系未知
		int min;
		int max;
		if (i == j) {
			if (i == len - 1) { // i后面无元素
                min = nums[i];
				int minI = Arrays.binarySearch(nums, 0, i, min);
				int maxI = len - 1;
				if (minI < 0) {
					minI = -(minI + 1);
				} else {
					while (minI < len && nums[minI] == min) // 往后跳过所有与min相同的元素
						minI++;
				}
				return maxI - minI + 1;
			} else { //// i后面的元素都是升序排列
				min = Math.min(nums[i], nums[i + 1]);
				max = nums[i - 1];
			}
		} else {
			min = nums[i];
			max = nums[j];
			for (int k = i; k <= j; k++) {
				if (nums[k] < min)
					min = nums[k];
				if (nums[k] > max)
					max = nums[k];
			}
			min = Math.min(min, nums[j + 1]);
			max = Math.max(max, nums[i - 1]);
		}

		// 现在,[i,j]就是乱序的序列, 需要从中找出max,min
		int minI = Arrays.binarySearch(nums, 0, i, min);
		if (minI < 0) {
			minI = -(minI + 1);
		} else {
			while (minI < len && nums[minI] == min) // 往后跳过所有与min相同的元素
				minI++;
		}

		int maxI = Arrays.binarySearch(nums, j + 1, len, max);
		if (maxI < 0) {
			maxI = -(maxI + 1) - 1;// 注意这里, maxI的取值是[j + 1, len],
									// 但j以后的元素不能向后挪,所以插入位置应该相应减一
		} else {
			while (maxI > -1 && nums[maxI] == max) // 往前跳过所有与max相同的元素
				maxI--;
		}
		return maxI - minI + 1;
	}
}
//80%-90%
