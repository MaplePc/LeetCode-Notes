Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.

Example 1:
Input: [1, 2, 2, 3, 1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
Example 2:
Input: [1,2,2,3,1,4,2]
Output: 6
Note:

nums.length will be between 1 and 50,000.
nums[i] will be an integer between 0 and 49,999
===============================================
class Solution {
	public int findShortestSubArray(int[] nums) {

		char[][] map = new char[50000][2]; //[0]=起始,[1]=计数/度数
		char degree = 0;
		char length = 0;
		for (char i = 0; i < nums.length; i++) {
			map[nums[i]][1]++;

			if (map[nums[i]][1] == 1) { //第一次出现
				map[nums[i]][0] = i;
			}
			if (map[nums[i]][1] == degree) {
				length = (char) Math.min(length, i - map[nums[i]][0] + 1);
			} else if (map[nums[i]][1] > degree) {
				degree = map[nums[i]][1];
				length = (char) (i - map[nums[i]][0] + 1);
			}
		}
		return length;
	}
}
//2%-4%, mmp, 应该是样例数据太少了, 每次开辟50000空间性价比不高
//数据量太少且取值范围较宽的时候不适合用hash数组
//太稀疏, 空间利用率太低, 而开辟连续内存可能还要进行GC
//hash带来的效率的提升被开辟空间消耗的时间抵消掉了
