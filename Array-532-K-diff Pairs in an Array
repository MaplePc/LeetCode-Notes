Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.

Example 1:
Input: [3, 1, 4, 1, 5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
Example 2:
Input:[1, 2, 3, 4, 5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
Example 3:
Input: [1, 3, 1, 5, 4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
Note:
The pairs (i, j) and (j, i) count as the same pair.
The length of the array won't exceed 10,000.
All the integers in the given input belong to the range: [-1e7, 1e7].
=====================================================
class Solution {
    public int findPairs(int[] nums, int k) {
        int len = nums.length;
        if(k < 0 || len < 1)
            return 0;
        
        // int max = (int)(1e7);
        // int min = (int)(-1e7); //分配这么大的空间所需等待的时间很长
        
        int max = nums[0];
        int min = nums[0];
        for(int v : nums){
            if(v > max) 
                max = v;
            if(v < min)
                min = v;
        }
        
        int[] hash = new int[max - min + 1]; //[0, max - min]; 如果最大最小值之差很大, 所需的空间会很多, 分配的时间也比较长, 这是算法效率不高的原因(受极端输入数据的影响很大)
        for(int v : nums){          //利用哈希数组统计值出现的次数
            hash[v - min]++;
        }
        
        int count = 0;
        if(k == 0){ //寻找至少出现两次的值的个数
            for(int v : nums){
                if(hash[v - min] > 1){  //至少出现两次
                    count++;
                    hash[v - min] = 0; //清零, 避免重复计算
                }
            }    
            
        }
        else{
            for(int v : nums){
                if(hash[v - min] > 0){
                    if(v - k - min > -1 && hash[v - k - min] > 0) //查找比v小K的值
                        count++;
                    if(v + k <= max && hash[v + k - min] > 0)   //查找比v大k的值
                        count++;                    
                    hash[v - min] = 0; //清零, 避免重复计算
                }
            }           
        }
        return count;
    }
}
//7%
