Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.
============================================
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	public TreeNode buildTree(int[] pre, int[] in) {
		int len = pre.length;
		if (len == 0)
			return null;

		int max = in[0];
		int min = in[0];
		for (int v : in) {
			if (v > max)
				max = v;
			if (v < min)
				min = v;
		}

		max = Math.max(Math.abs(max), Math.abs(min));
		min = -max;
		short[] hash = new short[2 * max + 1];
		for (int i = 0; i < len; i++) {
			hash[in[i] - min] = (short) i;
		}

		return subTree(hash, min, pre, 0, len - 1, in, 0, len - 1);
	}

	//用pre数组中下标范围是[preL, preR]的元素和对应的in数组中下标范围是[inL, inR]的元素构造一颗(子)二叉树
	public TreeNode subTree(short[] hash, int min, int[] pre, int preL, int preR, int[] in, int inL, int inR) {
		if (preL > preR)
			return null;

		int val = pre[preL]; //取pre中第一个元素, 其值为val
		TreeNode curNode = new TreeNode(val);
		int i = hash[val - min];
		curNode.left = subTree(hash, min, pre, preL + 1, preL + (i - inL), in, inL, i - 1);
		curNode.right = subTree(hash, min, pre, preL + 1 + (i - inL), preR, in, i + 1, inR);
		return curNode;

	}
}
//98%
