
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
============================================

class Solution {
	public static int maxSubArray(int[] nums) {
		int i = 0;
		int maxI = 0; // 当前面的nums[i]都<=0时的最大值的下标
		// 1.数组都是非正数,所以要挑选最大值
		while (i < nums.length && nums[i] <= 0) {
			if (nums[i] > nums[maxI]) {
				maxI = i;
			}
			i++;
		}
		if (i == nums.length) {
			return nums[maxI];
		}

		// 2.子数组的首元素是正数, 所以接下来要挑选应该包含到子数组里的元素
		//类比说明: 1)食物:元素 2)胃:子数组 3)嘴:tempSum
		//形象化描述:胃试图放下数量最多的食物, 直到遇到一个确实吃不下的食物或没有食物为止; 反刍过程: 胃把食物倒回到嘴里, 嘴检查吃下的食物是否真的"营养丰富"
		int startI = 0; // 当前子数组的起始坐标
		int sum = 0; // 子数组元素值的累加值
		int largestSum = 0; // 最终结果,连续子数组的元素值的最大累加值
		while (i < nums.length) {
			if (sum == 0) {
				if (nums[i] > 0) {// 发现一个新的子数组
					sum = nums[i];
					startI = i; // 子数组的起始下标
					if (i == nums.length - 1) { // 子数组刚开始就结束
						largestSum = nums[i] > largestSum ? nums[i] : largestSum;
					}
				}
			} else { // 找到了子数组,贪吃ing
				if (nums[i] < 0 && sum <= -nums[i] || i == nums.length - 1) {// 吃不下,检查胃里面的东西,然后重新寻找子数组;或者没得吃了,也检查胃
					int tempSum = 0; // "嘴": 将tempSum定义为当前子数组尾部元素的累加值
					if (i == nums.length - 1 && nums[i] > 0) { // 如果最后一个是正数,先吃再说
						sum += nums[i]; //吃掉
						tempSum = nums[i]; //反刍
					}
					// 此时得到的sum为子数组贪婪包含元素得到的最大累加值

					// 注意:此处当sum<largestSum时,不能简单地抛弃掉sum(因为sum可以通过吐出一些"食物"使其值增大)
					// "反刍": 从后往前把子数组的元素倒出来, 放到"嘴"tempSum中(因为之前可能贪婪地包含了一些负数,现在要回顾看到底能不能吃)
					for (int j = i - 1; j > startI; j--) {
						if (nums[j] < 0 && tempSum <= -nums[j]) { // 如果后面吃的正数(sum)都抵不上或刚好抵得上现在吃的这个负数(nums[j]),把nums[j]和sum都吐出来
							sum = sum - nums[j] - tempSum;
							tempSum = 0; // 把嘴里的食物吐出来
						} else { // 如果能吃(正数,0,或绝对值小于等于tempSum的负数)
							tempSum += nums[j];
						}
					}
					largestSum = sum > largestSum ? sum : largestSum;
					sum = 0; // 为寻找新的子数组初始化
				} else { // 如果吃得下(正数,0,或绝对值小于等于sum的负数)
					sum += nums[i];
				}
			}
			i++;
		}
		return largestSum;
	}
}
