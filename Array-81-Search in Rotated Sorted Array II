Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Write a function to determine if a given target is in the array.

The array may contain duplicates.
==============================================
class Solution {
    public boolean search(int[] nums, int tar) {
        int len = nums.length;
        if(len == 0)
            return false;
        
        int l = 0;
        int r = len - 1;
        int mid = 0;
        while(l < r){
            mid = l + (r - l) / 2;
            if(tar == nums[mid])
                return true;
            else if(tar > nums[mid]){
                if(tar <= nums[r]) //右边有序
                    l = mid + 1;
                else{ //断层的位置未知
                    boolean right = false; //tar和断层应该在右边?
                    for(int i = mid + 1; i <= r; i++){
                        if(nums[i] < nums[i - 1]) //断层出现在右边
                            right = true;
                    }
                    
                    if(right)
                        l = mid + 1; //断层在右边, tar也应该在右边
                    else
                        r = mid - 1;
                }
                    
            }
            else{ //tar < nums[mid]
                if(tar >= nums[l]) //[l] <= tar < [mid], 左边有序
                    r = mid - 1;
                else{ //tar < [l], 断层的位置未知
                    boolean right = false; //tar和断层应该在右边?
                    for(int i = mid + 1; i <= r; i++){
                        if(nums[i] < nums[i - 1]) //断层出现在右边
                            right = true;
                    }
                    if(right)
                        l = mid + 1; //断层在右边, tar也应该在右边
                    else 
                        r = mid - 1;
                }
                    
            }
                
        }
        if(nums[l] == tar)
            return true;
        
        return false;
    }
}
//9%, 第一个柱形
